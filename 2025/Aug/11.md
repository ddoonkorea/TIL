2025.08.11

팝업 만들기

CMenu는 전체 메뉴를 담을 수 있는 하나의 객체이다.

pSubMenu는 첫번째 메뉴의 시작 주소값을 알기위해 사용한다.

TrackPopupMenu 핸들러를 보면, TPM_LEFTBUTTON은 사용자는 마우스 왼쪽 단추만 사용하여 메뉴 항목을 선택할 수 있습니다. 를 의미한다.

TPM_LEFTALIGN은 바로 가기 메뉴를 배치하여 왼쪽이 *x* 매개 변수로 지정된 좌표에 맞춰지도록 합니다.
300, 300은 좌표값인데 내가 마우스를 클릭한 곳에 나오지않고 고정된 위치에 나오기 팝업이 나오기 때문에 바꿔주어야한다.

**GetSubMenu 함수는 지정된 메뉴 항목에 의해 활성화된 드롭다운 메뉴 또는 하위 메뉴에 대한 핸들을 검색합니다.**
CPoint ptPopup = point;
this->ClientToScreen(&ptPopup);
실제 사용자의 좌표를 가져오는 코드이다.
ptPopup.x, ptPopup.y를 사용하면 x,y 좌표를 이용해서 구할 수 있다.

GDI
## GDI (Graphics Device Interface)

코드로 화면을 그려내는 것

렌더링은 WM_ERASEBKGND → WM_PAINT순으로 실행된다.

렌더링을 반복하면 깜빡이는거처럼 보이는데 이를 더블 버퍼링이라 한다.

렌더링 처리가 늦어지면 os는 응답없음 상태로 간주한다.

## DC : Device Context

DC가 비트맵을 갖지 않으면 출력 불가

특정 윈도우에 대한 DC는 비트맵을 가짐

메모리 DC에 그림을 그린 후, DC에 블릿(복사)하여 한번에 보여주는것이 더블 버퍼링이다.

GDI에서는 RGB를 사용하며, 24비트를 사용한다.

GDI+에서는 ARGB를 사용하며, 32비트를 사용한다. A는 알파 채널이다.

```jsx
void CPenSampleView::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	CPen pen(PS_SOLID, 5, RGB(192, 0, 0));
	CPen penBlue(PS_SOLID, 5, RGB(0, 0, 192));

	dc.SelectObject(&pen);
	dc.MoveTo(100, 100);
	dc.LineTo(200, 100);

	dc.SelectObject(&penBlue);
	dc.MoveTo(100, 200);
	dc.LineTo(200, 200);

}
```

선을 그리기위해 먼저 CPaintDC 클래스의 dc객체를 만든다.

MoveTo는 해당 좌표로 이동을 해서 LineTo로 선을 긋는다.

CPen 클래스에서 pen객체를 만드는데, 펜의 설정을 변경한 것이다.

그러나 바로 적용되지 않고 *pOldPen 변수를 만듥고 SelectObject로 펜을 선택해 줘야 적용 된다.

일반 객체로 변수를 만들게 되면, 값을 사용할때 &를 붙여서 시작 주소를 알아야 한다.

반대로 포인터로 변수를 만들게 되면, 시작주소는 알기 때문에 그냥 변수명만 사용하면 된다.

```jsx
	COLORREF cBlue = RGB(0, 0, 192);를 사용가능
	CPen penBlue(PS_SOLID, 5, cBlue);
	
```