2025.08.15

사용자의 키보드 입력을 처리하는 함수는 Win32API함수로 GetKeyState()

### 키보드 입력

- 키보드와 마우스(HID)는 각각 유일한 입력장치
- 한 프로그램이 독점하지 말아야 한다.
- 모든 키보드 입력은 입력 포커스를 가진 응용 프로그램에 전달되는것이 원칙이다.
- 입력한 키 값은 Virtual key code로 변환해 전달된다.
- 키를 계속 누르고 있을 경우 지속적으로 메시지는 계속 발생한다.

void CInputSampleView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	OutputDebugString(_T("OnKeyDOwn()\n"));
	CView::OnKeyDown(nChar, nRepCnt, nFlags);
}

출력 창에서 보면 내가 어떤 키를 누르던 OnKeyDOwn()이 출력된다.

모든 키가 아닌 알파벳 키만 출력하고싶으면 WM_CHAR 메시지를 추가해야한다.

void CInputSampleView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	OutputDebugString(_T("OnKeyDOwn()\n"));
	CView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CInputSampleView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	CClientDC dc(this);
	m_char = nChar;
	RedrawWindow();
	CView::OnChar(nChar, nRepCnt, nFlags);
}

void CInputSampleView::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	dc.SetBkMode(OPAQUE);
	dc.SetBkColor(RGB(255, 255, 255));

	if (m_char != 0) {
		CString tmp;
		tmp.Format(_T("%c"), m_char);

		if (::GetKeyState(VK_SHIFT) & 0x8000)
			tmp += _T(" [SHIFT] ");

		dc.TextOut(10, 10, tmp);
	}

}

OnKeyDown 함수를 보면 어떤 키가 눌리던 출력창에 전부 출력됐다.

문자열만 화면에 출력하기위해 OnChar 핸들러를 추가했고, OnPaint에서 nChar값을 사용할 수 없었기 때문에 멤버 변수로 m_char변수를 추가했다.

키가 눌릴때마다 RedrawWindow()함수를 통해 화면에 출력된다.

m_char은 초기값을 0으로 초기화했기때문에 화면상에 0이 먼저 출력돼서 조건문을 추가했다.

Shift 키가 눌린 상태를 알려주기위해 GetKeyState()함수를 사용했다.

## 마우스 이동

- 마우스 이동 시 WM_MOUSEMOVE 메시지가 발생하며 마우스 포인터 좌표값을 매개변수로 함께 전달
- 윈도우 영역을 벗어날 경우 메시지를 수신하지 못함
- 윈도우 속성에 따라 마우스 메시지를 수신하지 않을 수 있음
- 터치스크린이나 태블릿 역시 마우스와 동일하게 처리
- ex) 드래그앤 드롭 : 1. Down 2. Move 3. Up

## 버튼 클릭

- 윈도우 환경에서 마우스 버튼은 기본적으로 3개
- 왼쪽, 중앙 휠, 오른쪽
- 제어판 설정에 따라 좌우가 바뀔 수 있음(왼손)
- 모든 버튼은 Down, Up 메시지를 가짐
- 클릭 이벤트에 대한 처리를 원한다면 Down이 아닌 Up 메시지 활용을 권장
- 더블 클릭은 마우스 버튼 Down + Up의 연속 발생 시 추가되는 메시지
- Drag and drop은 마우스 버튼 Down, Move, Up 세 메시지의 연속

먼저 마우스 좌표를 구하기위해 CPoint m_ptMove 변수를 선언해주었다.

	if (m_ptMove.x > 0 && m_ptMove.y > 0) {
		tmp.Format(_T("X: %d, Y: %d"), m_ptMove.x, m_ptMove.y);
		dc.TextOut(10, 30, tmp);
	}
	dc.FillSolidRect(&m_rtIcon, RGB(192, 192, 192));
	
	.h파일
	CRect m_rtIcon = CRect(10, 100, 110, 200);

그리고 x,y값을 화면에 보여주고, 드래그 앤 드롭에 필요한 m_rtIcon을 만들어주었다. 

void CInputSampleView::OnMouseMove(UINT nFlags, CPoint point)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	m_ptMove = point;
	RedrawWindow();
	CView::OnMouseMove(nFlags, point);

}

void CInputSampleView::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (m_rtIcon.PtInRect(point))
	{
		AfxMessageBox(_T("pt in rect"));
	}
	CView::OnLButtonDown(nFlags, point);
}

void CInputSampleView::OnLButtonUp(UINT nFlags, CPoint point)
{

	CView::OnLButtonUp(nFlags, point);
}


point값으로 m_rtIcon 안에서 클릭을 했을 때 메시지가 출력되게 하는것이 첫번째였다.

void CInputSampleView::OnMouseMove(UINT nFlags, CPoint point)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	m_ptMove = point;
	if (m_bDrag) {
		m_rtIcon.TopLeft() = point - m_offset;
		m_rtIcon.BottomRight() = m_rtIcon.TopLeft() + CSize(100, 100);
	}
	RedrawWindow();
	CView::OnMouseMove(nFlags, point);

}

void CInputSampleView::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (m_rtIcon.PtInRect(point))
	{
		m_bDrag = TRUE;
		m_offset = point - m_rtIcon.TopLeft();
		SetCapture();
	}

	CView::OnLButtonDown(nFlags, point);
}

void CInputSampleView::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bDrag) {
		m_rtIcon.TopLeft() = point - m_offset;
		m_rtIcon.BottomRight() = m_rtIcon.TopLeft() + CSize(100, 100);
		RedrawWindow();
		ReleaseCapture();
	}
	m_bDrag = FALSE;

	CView::OnLButtonUp(nFlags, point);
}

마우스 영역이 화면 밖으로 사라졌을 떄도 유지하려면 SetCapture() 함수, ReleaseCapture() 함수를 사용할 수 있다. TopLeft가 point - m_offset인데 내가 찍은 좌표 - 마우스 클릭 위치와 도형 좌측 상단의 차이만큼 이동 보정해주는 것이다.

## 휠 버튼은 매개변수로 스크롤 범위를 전달 받는다.