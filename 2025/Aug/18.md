2025.08.18

dc.FillSolidRect(도형, 색상 RGB(192,192,192)) : 앞서 만든 객체를 눈앞에 보이게 색을 칠함.

void CVirtualBtnView::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_btn.PtInRect(point)) {

	}
	CView::OnMouseMove(nFlags, point);
}

PtInRect(point) : 도형안에 마우스가 있는지 없는지 확인

dc.DrawText(_T("TEST btn"), &m_btn, DT_CENTER | DT_SINGLELINE | DT_VCENTER);

TEST btn이라는 문구를 m_btn도형안에 넣는다. 디자인은
DT_CENTER : 가로로 가운데 정렬
DT_SINGLELINE : 한줄로 출력
DT_VCENTER : 세로로 가운데 정렬

void CVirtualBtnView::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_btn.PtInRect(point)) {
		PostMessage(WM_COMMAND, ID_TEST_TEST);
	}
	CView::OnLButtonUp(nFlags, point);
}

마우스 버튼이 올라갈 때 (클릭 했을 때)
PostMessage함수는 명령이 왔다는것을 알려주고, ID_TEST_TEST인 ID값의 버튼을 처리한다.
위에서
void CVirtualBtnView::OnTestTest()
{
	AfxMessageBox(_T("TEST"));
}
라고 정의 했기 때문에 TEST가 출력된다.


## 윈도우 텍스트


윈도우 텍스트
CEdit m_wndName;

int CVirtualBtnView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_wndName.Create(ES_LEFT | WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_BORDER,
		CRect(10, 10, 100, 40), this, 1);

	return 0;
}
View클래스에서 OnCreate 함수를 통해 추가할 수 있다.
가로 길이 90, 세로 길이 30 짜리의 입력가능한 텍스트 칸이 만들어진다.

OnPaint와 Create의 차이

앞서 만든  CRect와 같은 도형은 OnPaint함수를 사용하는데, CEdit클래스는 Create함수를 사용한다.

CRect, CPen과 같은 도형 객체는 직접 GDI로 그릴 수 있고, OnPaint함수로 처리한다..

CEdit, CButton 등과 같은 컨트롤 클래스는 윈도우에서 제공하는 UI 기능을 포함하기 때문에 Create()함수로 처리한다.

void CVirtualBtnView::OnTestTest()
{
	CString tmp;
	m_wndName.GetWindowText(tmp);
	AfxMessageBox(tmp);
}

tmp 문자열 객체를 선언하고, GetWindowText함수를 사용하면 내가 입력한 문자열을 가져오고
AfxMessage함수를 통해 보여준다.

탭 오더 : 탭 키를 눌렀을 때 넘어가는 순서

## 대화 상자 (Dialog)

```jsx
void CDlgSampleView::OnTestTest()
{
	CDlgTest dlg;
	dlg.DoModal();
}
아래 그림과같은 도움말을 눌렀을 때 나오는 모달창을 대화 상자라고 한다.
새로운 대화상자를 사용하기 위해 먼저 Dialog에 대화상자를 만들고, 대화상자 클래스를 추가한다.
Test 버튼에 이벤트 처리기를 추가하고, 그 안에 CDlgTest클래스의 객체를 만든다.
대화상자를 불러올 때는 DoModal() 함수를 사용한다.
```

확인 버튼을 눌렀을 때는 IDOK가 리턴된다. 

대화 상자 안에 Edit Control 칸을 만들고, 멤버 변수를 추가하면

이렇게 함수가 추가된다.

대화상자의 확인 버튼을 더블 클릭하면 알아서 MFC가 핸들러를 추가해준다.

그리고 알아서 m_strName변수에 내가 입력한 이름이 들어간다.

스태틱 컨트롤 윈도우

- 문자열을 표시하는 것에 특수화된 컨트롤
- 메시지를 받지 않는 것이 기본 속성

에디트 컨트롤 윈도우

- 문자열 입력을 입력 받는 기능에 특수화
- 복사넣기와 붙여넣기 기능 제공

## DDX/DDV 매커니즘

- 컨트롤 윈도우에 대한 멤버 등록 시 윈도우 객체 혹은 데이터 객체로 등록
- 윈도우 객체 사용 시 데이터 동기화 코드 추가
- 컨트롤 윈도우와 데이터 객체 연동 자동화
- 컨트롤과 멤버 데이터 간 매핑 설정에 따라 동기화
- Updatedata() 함수를 호출해 동기화
- 자료에 대한 유효성 검사 기능 제공

UpdateData(TRUE)면 입력한 값 등을 멤버 변수로 가져온다.

UpdateData(FALSE)면 멤버 변수의 값을 컨트롤에 표시한다.

다이얼로그에서 탭오더의 순서를 정하는 단축키는 Ctrl + D이다.

빠른 테스트는 Ctrl + T 누르면 다음과 같이 뜬다.

이렇게 이름, 비밀번호, 나이를 입력 하는 칸과 초기에 보여주는 Test String 문자열을 보았다.

저렇게 입력받아서 보여주는건 UpdateData(TRUE)가 오고, 처음부터 업데이트 없이 보여주는건 UpdateData(FALSE)가 된다. UpdateData가 TRUE가 되면 멤버 변수에 업데이트 한다.

이렇게 Age로 설정할 경우 최소값 최댓값을 설정할 수 있다.

순서 정리 : 

1. 리소스 뷰에서 Edit Control이나 Text Control을 추가한다.
2. ID값을 바꿔준다.
3. 대화 상자 클래스를 하나 추가한다.
4. 각 멤버 변수를 추가한다.
5. 멤버 변수를 추가하면 DDX에 자동으로 추가된다.
6. 재정의에서 OnInitDialog함수를 추가하고 UpdateData(FALSE)를 호출하면 화면에 초기값이 표시된다.
7. OK 버튼 클릭 시 UpdateData(TRUE) → 컨트롤 → 멤버 변수에 저장된다.

EditControl에 새로운 이벤트를 추가할건데 EditControl의 부모는 대화상자이므로 클래스를 View클래스가 아닌 DlgTest클래스를 선택해야 한다.

```jsx
void CDlgTest::OnEnSetfocusEditName()
{
	m_strTest = _T("이름을 10자 이하로 입력하세요.");
	UpdateData(FALSE);
}

void CDlgTest::OnEnKillfocusEditName()
{
	m_strTest = _T("");
	UpdateData(FALSE);
}

이름을 입력하는 EditControl에 포커스가 가있으면 위 문구가 나타나고,
포커스를 다른곳으로 옮기면 아무 문구도 나오지 않는다. 

모달 방식과 모델리스 방식이다.

모달은 창 하나만 띄울 수 있고, 모델리스는 여러개를 띄울 수 있다.

먼저 DoModal() 함수는 모달 방식이고, Create방식은 모델리스 방식이다.

그리고 추가로 지역변수로 선언한 dlg는 스코프가 종료되면 스택영역에서 자동으로 사라진다.

*pDlg는 동적으로 생성한것이고, 힙영역에 생성된다. 객체의 주소를 가리키기떄문에 화살표 연산자를 사용한다.

static CDlgML dlg; 이렇게 static을 사용하게되면 프로그램이 종료될 때까지 사라지지 않는다.

프로그램이 종료되면 소멸자가 알아서 지운다.

	static CDlgML dlg;

	if(dlg.GetSafeHwnd() == NULL)
	dlg.Create(ID_MODELESS);

	dlg.ShowWindow(SW_SHOW);
	
	대화상자를 닫아도 그 자리에 다시 생성할수있음
